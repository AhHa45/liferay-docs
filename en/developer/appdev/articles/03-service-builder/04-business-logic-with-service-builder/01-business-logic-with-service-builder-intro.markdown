---
header-id: business-logic-with-service-builder
---

# Business Logic with Service Builder

[TOC levels=1-4]

Once you've
[defined your application's entities](/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file)
and
[run Service Builder](/docs/7-2/appdev/-/knowledge_base/a/running-service-builder)
to generate your service and persistence layers, you can begin adding business
logic. Each entity generated by Service Builder contains a model implementation,
local service implementation, and optionally a remote service implementation
class. Your application's business logic can be implemented in these classes.
The generated service layer contains default methods that call CRUD operations
from the persistence layer. Once you've added your business logic, running Service
Builder again regenerates your application's interfaces and makes your new logic
available for invocation.

The heart of your service is its `*LocalServiceImpl` class. This class is your
entity's local service extension point. Local services are invoked from your
application or by other applications running on the same instance as your
application. 

Creating services takes these steps: 

1.  Deciding to Create Local and Remote Services.

2.  Implementing the `add` Method.

3.  Implementing the `update` and `delete` Methods.

4.  Implementing Finder and Counter Methods

5.  Implementing Other Business Logic

6.  Integrating with Liferay's Services.

Start with deciding the service types you need. 

[Defining your object model](/docs/7-2/appdev/-/knowledge_base/a/creating-the-service-xml-file)
involves choosing whether to generate local and or remote service interfaces.
Local services can only be invoked from the Liferay server on which they're
deployed. Remote services are accessible to clients outside of the Liferay
server. Before implementing local or remote services, consider the best
practices described here:

1.  If you plan to have remote services, enable local services too.

2.  Implement your business logic in `*LocalServiceImpl`. 

3.  Create corresponding remote services methods in your 
    `*ServiceImpl`.

4.  Use the remote service methods to call the local service, wrapping the calls
    in permission checks. 

5.  In your application, call only the remote services. This ensures that
    your service methods are secured and that you don't have to duplicate
    permissions code.

If you are turning on local or remote services in your `service.xml` file just
now, make sure to
[run Service Builder](/docs/7-2/appdev/-/knowledge_base/a/running-service-builder)
again to generate the service interfaces. 

## Service Method Prefixes and Database Transactions

There are two kinds of database transaction precipitated by your Service Builder
project's service methods: READ-WRITE and plain old READ.  Methods making
persistence changes must be recognized as READ-WRITE methods, and the method
name prefix is used to ascertain this need. If a service [method is
prefixed](https://github.com/liferay/liferay-portal/blob/master/modules/util/portal-tools-service-builder/src/main/java/com/liferay/portal/tools/service/builder/ServiceBuilderArgs.java)
with any of these words, it's going to precipitate a database READ:

- `dynamicQuery`
- `fetch`
- `get`
- `has`
- `is`
- `load`
- `reindex`
- `search`

Otherwise, a READ-WRITE transaction is made. Therefore, avoid naming your
persistence methods (for adding, updating, and deleting, for example) with any
of these prefixes.

## Nested Service Calls and Transactions

Because of the distinction between READ and READ-WRITE transactions, you must be
careful to avoid making service calls that you expect to persist data within a
method that executes a READ transaction. For example, you might be tempted to write
a method in `MyEntityLocalServiceImpl` called `getOrAddMyEntity`, with the goal of first
trying to retrieve the entity from the database, and if there are none returned,
then call the `addMyEntity` method. This doesn't work, because the `get` prefix
forces this to use only a READ transaction. If you were to instead use the
method name `addOrGetMyEntity`, a READ-WRITE transaction would be invoked, and
your logic would successfully read from the database, and if no entities were
already found, the `addMyEntity` method would work as expected, since the
transaction is of the appropriate type. 

Now you're ready to implement your business logic. 
